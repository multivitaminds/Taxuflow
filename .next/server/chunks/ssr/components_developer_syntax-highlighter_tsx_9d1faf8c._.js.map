{"version":3,"sources":["../../../../components/developer/syntax-highlighter.tsx"],"sourcesContent":["\"use client\"\n\nimport { memo } from \"react\"\n\ninterface Token {\n  type:\n    | \"keyword\"\n    | \"string\"\n    | \"number\"\n    | \"function\"\n    | \"property\"\n    | \"operator\"\n    | \"punctuation\"\n    | \"comment\"\n    | \"text\"\n    | \"method\"\n    | \"variable\"\n    | \"boolean\"\n    | \"null\"\n  value: string\n}\n\nconst tokenize = (code: string, language: string): Token[] => {\n  const tokens: Token[] = []\n\n  // Enhanced keywords for multiple languages\n  const keywords = [\n    \"const\",\n    \"let\",\n    \"var\",\n    \"function\",\n    \"async\",\n    \"await\",\n    \"return\",\n    \"import\",\n    \"from\",\n    \"export\",\n    \"default\",\n    \"class\",\n    \"extends\",\n    \"new\",\n    \"this\",\n    \"if\",\n    \"else\",\n    \"for\",\n    \"while\",\n    \"switch\",\n    \"case\",\n    \"break\",\n    \"continue\",\n    \"try\",\n    \"catch\",\n    \"throw\",\n    \"typeof\",\n    \"instanceof\",\n    \"require\",\n    \"package\",\n    \"func\",\n    \"main\",\n    \"<?php\",\n    \"curl\",\n    \"npm\",\n    \"pip\",\n    \"git\",\n    \"true\",\n    \"false\",\n    \"null\",\n    \"undefined\",\n  ]\n\n  const operators = [\"=\", \"+\", \"-\", \"*\", \"/\", \"&&\", \"||\", \"!\", \"===\", \"!==\", \"==\", \"!=\", \":=\", \"=>\", \"->\", \"\\\\\"]\n\n  const lines = code.split(\"\\n\")\n\n  lines.forEach((lineContent, lineIndex) => {\n    const trimmed = lineContent.trim()\n\n    // Check for comments (various styles)\n    if (trimmed.startsWith(\"//\") || trimmed.startsWith(\"#\")) {\n      tokens.push({ type: \"comment\", value: lineContent })\n      if (lineIndex < lines.length - 1) tokens.push({ type: \"text\", value: \"\\n\" })\n      return\n    }\n\n    // Regex-based tokenization for better accuracy\n    const regex = /(\"(?:[^\"\\\\]|\\\\.)*\"|'(?:[^'\\\\]|\\\\.)*'|\\b\\d+\\.?\\d*\\b|[a-zA-Z_$][a-zA-Z0-9_$]*|\\s+|[^\\s\\w])/g\n    const matches = lineContent.match(regex) || []\n\n    matches.forEach((match) => {\n      // String literals\n      if (/^[\"']/.test(match)) {\n        tokens.push({ type: \"string\", value: match })\n      }\n      // Numbers\n      else if (/^\\d/.test(match)) {\n        tokens.push({ type: \"number\", value: match })\n      }\n      // Booleans and null\n      else if (match === \"true\" || match === \"false\") {\n        tokens.push({ type: \"boolean\", value: match })\n      } else if (match === \"null\" || match === \"undefined\") {\n        tokens.push({ type: \"null\", value: match })\n      }\n      // Keywords\n      else if (keywords.includes(match)) {\n        tokens.push({ type: \"keyword\", value: match })\n      }\n      // Function/method calls (word followed by parenthesis)\n      else if (/^[a-zA-Z_$][a-zA-Z0-9_$]*$/.test(match)) {\n        // Check if next non-whitespace token is '('\n        const nextIndex = matches.indexOf(match) + 1\n        if (nextIndex < matches.length && matches[nextIndex].trim() === \"(\") {\n          tokens.push({ type: \"function\", value: match })\n        } else {\n          // Check if it looks like a property (after a dot)\n          const prevIndex = matches.indexOf(match) - 1\n          if (prevIndex >= 0 && matches[prevIndex].trim() === \".\") {\n            tokens.push({ type: \"property\", value: match })\n          } else {\n            tokens.push({ type: \"variable\", value: match })\n          }\n        }\n      }\n      // Operators\n      else if (operators.some((op) => match.includes(op))) {\n        tokens.push({ type: \"operator\", value: match })\n      }\n      // Punctuation\n      else if (/^[{}()[\\],;:.]$/.test(match)) {\n        tokens.push({ type: \"punctuation\", value: match })\n      }\n      // Whitespace and everything else\n      else {\n        tokens.push({ type: \"text\", value: match })\n      }\n    })\n\n    if (lineIndex < lines.length - 1) {\n      tokens.push({ type: \"text\", value: \"\\n\" })\n    }\n  })\n\n  return tokens\n}\n\nexport const SyntaxHighlighter = memo(({ code, language }: { code: string; language: string }) => {\n  const tokens = tokenize(code, language)\n\n  return (\n    <code className=\"text-sm font-mono leading-relaxed\">\n      {tokens.map((token, i) => {\n        const className = {\n          keyword: \"text-[#ff79c6] font-semibold\", // Pink for keywords\n          string: \"text-[#50fa7b]\", // Green for strings\n          number: \"text-[#bd93f9]\", // Purple for numbers\n          boolean: \"text-[#bd93f9]\", // Purple for booleans\n          null: \"text-[#bd93f9]\", // Purple for null/undefined\n          function: \"text-[#8be9fd]\", // Cyan for functions\n          method: \"text-[#8be9fd]\", // Cyan for methods\n          property: \"text-[#f1fa8c]\", // Yellow for properties\n          variable: \"text-[#f8f8f2]\", // Off-white for variables\n          operator: \"text-[#ff79c6]\", // Pink for operators\n          punctuation: \"text-[#6272a4]\", // Gray-blue for punctuation\n          comment: \"text-[#6272a4] italic\", // Gray for comments\n          text: \"text-[#f8f8f2]\", // Off-white for text\n        }[token.type]\n\n        return (\n          <span key={i} className={className}>\n            {token.value}\n          </span>\n        )\n      })}\n    </code>\n  )\n})\n\nSyntaxHighlighter.displayName = \"SyntaxHighlighter\"\n"],"names":[],"mappings":"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"}